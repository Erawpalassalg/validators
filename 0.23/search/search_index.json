{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"validators - Python Data Validation for Humans\u2122","text":"<p>Python has all kinds of data validation tools, but every one of them seems to require defining a schema or form. I wanted to create a simple validation library where validating a simple value does not require defining a form or a schema.</p> <pre><code>&gt;&gt;&gt; import validators\n&gt;&gt;&gt; \n&gt;&gt;&gt; validators.email('someone@example.com')\nTrue\n</code></pre>"},{"location":"#resources","title":"Resources","text":"<ul> <li>Documentation</li> <li>Bugtracker</li> <li>Security</li> <li>Code</li> </ul>"},{"location":"references/between/","title":"between","text":""},{"location":"references/between/#validators.between.between","title":"<code>validators.between.between(value, /, *, min_val=None, max_val=None)</code>","text":"<p>Validate that a number is between minimum and/or maximum value.</p> <p>This will work with any comparable type, such as floats, decimals and dates not just integers. This validator is originally based on WTForms-NumberRange-Validator.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; between(5, min_val=2)\n# Output: True\n&gt;&gt;&gt; between(13.2, min_val=13, max_val=14)\n# Output: True\n&gt;&gt;&gt; between(500, max_val=400)\n# Output: ValidationError(func=between, args=...)\n&gt;&gt;&gt; between(\n...     datetime(2000, 11, 11),\n...     min_val=datetime(1999, 11, 11)\n... )\n# Output: True\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>PossibleValueTypes</code> <p>Value which is to be compared.</p> required <code>min_val</code> <code>Union[PossibleValueTypes, AbsMin, None]</code> <p>The minimum required value of the number. If not provided, minimum value will not be checked.</p> <code>None</code> <code>max_val</code> <code>Union[PossibleValueTypes, AbsMax, None]</code> <p>The maximum value of the number. If not provided, maximum value will not be checked.</p> <code>None</code> <p>Returns:</p> Type Description <code>Literal[True]</code> <p>If <code>value</code> is in between the given conditions.</p> <code>ValidationError</code> <p>If <code>value</code> is not in between the given conditions.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>min_val</code> is greater than <code>max_val</code>.</p> <code>TypeError</code> <p>If there's a type mismatch during comparison.</p> Note <ul> <li><code>PossibleValueTypes</code> = <code>TypeVar(\"PossibleValueTypes\", int, float, str, datetime)</code></li> <li>If neither <code>min_val</code> nor <code>max_val</code> is provided, result will always be <code>True</code>.</li> </ul> Source code in <code>src/validators/between.py</code> <pre><code>@validator\ndef between(\n    value: PossibleValueTypes,\n    /,\n    *,\n    min_val: Union[PossibleValueTypes, AbsMin, None] = None,\n    max_val: Union[PossibleValueTypes, AbsMax, None] = None,\n):\n    \"\"\"Validate that a number is between minimum and/or maximum value.\n\n    This will work with any comparable type, such as floats, decimals and dates\n    not just integers. This validator is originally based on [WTForms-NumberRange-Validator][1].\n\n    [1]: https://github.com/wtforms/wtforms/blob/master/src/wtforms/validators.py#L166-L220\n\n    Examples:\n        &gt;&gt;&gt; from datetime import datetime\n        &gt;&gt;&gt; between(5, min_val=2)\n        # Output: True\n        &gt;&gt;&gt; between(13.2, min_val=13, max_val=14)\n        # Output: True\n        &gt;&gt;&gt; between(500, max_val=400)\n        # Output: ValidationError(func=between, args=...)\n        &gt;&gt;&gt; between(\n        ...     datetime(2000, 11, 11),\n        ...     min_val=datetime(1999, 11, 11)\n        ... )\n        # Output: True\n\n    Args:\n        value:\n            Value which is to be compared.\n        min_val:\n            The minimum required value of the number.\n            If not provided, minimum value will not be checked.\n        max_val:\n            The maximum value of the number.\n            If not provided, maximum value will not be checked.\n\n    Returns:\n        (Literal[True]):\n            If `value` is in between the given conditions.\n        (ValidationError):\n            If `value` is not in between the given conditions.\n\n    Raises:\n        (ValueError): If `min_val` is greater than `max_val`.\n        (TypeError): If there's a type mismatch during comparison.\n\n    Note:\n        - `PossibleValueTypes` = `TypeVar(\"PossibleValueTypes\", int, float, str, datetime)`\n        - If neither `min_val` nor `max_val` is provided, result will always be `True`.\n    \"\"\"\n    if value is None:\n        return False\n\n    if max_val is None:\n        max_val = AbsMax()\n    if min_val is None:\n        min_val = AbsMin()\n\n    try:\n        if min_val &gt; max_val:\n            raise ValueError(\"`min_val` cannot be greater than `max_val`\")\n    except TypeError as err:\n        raise TypeError(\"Comparison type mismatch\") from err\n\n    return min_val &lt;= value &lt;= max_val\n</code></pre>"},{"location":"references/btc_address/","title":"btc_address","text":""},{"location":"references/btc_address/#validators.btc_address.btc_address","title":"<code>validators.btc_address.btc_address(value)</code>","text":"<p>Return whether or not given value is a valid bitcoin address.</p> <p>Full validation is implemented for P2PKH and P2SH addresses. For segwit addresses a regexp is used to provide a reasonable estimate on whether the address is valid.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; btc_address('3Cwgr2g7vsi1bXDUkpEnVoRLA9w4FZfC69')\n# Output: True\n&gt;&gt;&gt; btc_address('1BvBMsEYstWetqTFn5Au4m4GFg7xJaNVN2')\n# Output: ValidationError(func=btc_address, args=...)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>Bitcoin address string to validate.</p> required <p>Returns:</p> Type Description <code>Literal[True]</code> <p>If <code>value</code> is a valid bitcoin address.</p> <code>ValidationError</code> <p>If <code>value</code> is an invalid bitcoin address.</p> <p>New in version 0.18.0.</p> Source code in <code>src/validators/btc_address.py</code> <pre><code>@validator\ndef btc_address(value: str, /):\n    \"\"\"Return whether or not given value is a valid bitcoin address.\n\n    Full validation is implemented for P2PKH and P2SH addresses.\n    For segwit addresses a regexp is used to provide a reasonable\n    estimate on whether the address is valid.\n\n    Examples:\n        &gt;&gt;&gt; btc_address('3Cwgr2g7vsi1bXDUkpEnVoRLA9w4FZfC69')\n        # Output: True\n        &gt;&gt;&gt; btc_address('1BvBMsEYstWetqTFn5Au4m4GFg7xJaNVN2')\n        # Output: ValidationError(func=btc_address, args=...)\n\n    Args:\n        value:\n            Bitcoin address string to validate.\n\n    Returns:\n        (Literal[True]):\n            If `value` is a valid bitcoin address.\n        (ValidationError):\n            If `value` is an invalid bitcoin address.\n\n    &gt; *New in version 0.18.0*.\n    \"\"\"\n    if not value:\n        return False\n\n    return (\n        # segwit pattern\n        re.compile(r\"^(bc|tc)[0-3][02-9ac-hj-np-z]{14,74}$\").match(value)\n        if value[:2] in (\"bc\", \"tb\")\n        else _validate_old_btc_address(value)\n    )\n</code></pre>"},{"location":"references/card/","title":"card","text":""},{"location":"references/card/#validators.card.amex","title":"<code>validators.card.amex(value)</code>","text":"<p>Return whether or not given value is a valid American Express card number.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; amex('378282246310005')\n# Output: True\n&gt;&gt;&gt; amex('4242424242424242')\n# Output: ValidationError(func=amex, args={'value': '4242424242424242'})\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>American Express card number string to validate</p> required <p>Returns:</p> Type Description <code>Literal[True]</code> <p>If <code>value</code> is a valid American Express card number.</p> <code>ValidationError</code> <p>If <code>value</code> is an invalid American Express card number.</p> <p>New in version 0.15.0.</p> Source code in <code>src/validators/card.py</code> <pre><code>@validator\ndef amex(value: str, /):\n    \"\"\"Return whether or not given value is a valid American Express card number.\n\n    Examples:\n        &gt;&gt;&gt; amex('378282246310005')\n        # Output: True\n        &gt;&gt;&gt; amex('4242424242424242')\n        # Output: ValidationError(func=amex, args={'value': '4242424242424242'})\n\n    Args:\n        value:\n            American Express card number string to validate\n\n    Returns:\n        (Literal[True]):\n            If `value` is a valid American Express card number.\n        (ValidationError):\n            If `value` is an invalid American Express card number.\n\n    &gt; *New in version 0.15.0*.\n    \"\"\"\n    pattern = re.compile(r\"^(34|37)\")\n    return card_number(value) and len(value) == 15 and pattern.match(value)\n</code></pre>"},{"location":"references/card/#validators.card.card_number","title":"<code>validators.card.card_number(value)</code>","text":"<p>Return whether or not given value is a valid generic card number.</p> <p>This validator is based on Luhn's algorithm.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; card_number('4242424242424242')\n# Output: True\n&gt;&gt;&gt; card_number('4242424242424241')\n# Output: ValidationError(func=card_number, args={'value': '4242424242424241'})\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>Generic card number string to validate</p> required <p>Returns:</p> Type Description <code>Literal[True]</code> <p>If <code>value</code> is a valid generic card number.</p> <code>ValidationError</code> <p>If <code>value</code> is an invalid generic card number.</p> <p>New in version 0.15.0.</p> Source code in <code>src/validators/card.py</code> <pre><code>@validator\ndef card_number(value: str, /):\n    \"\"\"Return whether or not given value is a valid generic card number.\n\n    This validator is based on [Luhn's algorithm][1].\n\n    [1]: https://github.com/mmcloughlin/luhn\n\n    Examples:\n        &gt;&gt;&gt; card_number('4242424242424242')\n        # Output: True\n        &gt;&gt;&gt; card_number('4242424242424241')\n        # Output: ValidationError(func=card_number, args={'value': '4242424242424241'})\n\n    Args:\n        value:\n            Generic card number string to validate\n\n    Returns:\n        (Literal[True]):\n            If `value` is a valid generic card number.\n        (ValidationError):\n            If `value` is an invalid generic card number.\n\n    &gt; *New in version 0.15.0*.\n    \"\"\"\n    if not value:\n        return False\n    try:\n        digits = list(map(int, value))\n        odd_sum = sum(digits[-1::-2])\n        even_sum = sum(sum(divmod(2 * d, 10)) for d in digits[-2::-2])\n        return (odd_sum + even_sum) % 10 == 0\n    except ValueError:\n        return False\n</code></pre>"},{"location":"references/card/#validators.card.diners","title":"<code>validators.card.diners(value)</code>","text":"<p>Return whether or not given value is a valid Diners Club card number.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; diners('3056930009020004')\n# Output: True\n&gt;&gt;&gt; diners('4242424242424242')\n# Output: ValidationError(func=diners, args={'value': '4242424242424242'})\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>Diners Club card number string to validate</p> required <p>Returns:</p> Type Description <code>Literal[True]</code> <p>If <code>value</code> is a valid Diners Club card number.</p> <code>ValidationError</code> <p>If <code>value</code> is an invalid Diners Club card number.</p> <p>New in version 0.15.0.</p> Source code in <code>src/validators/card.py</code> <pre><code>@validator\ndef diners(value: str, /):\n    \"\"\"Return whether or not given value is a valid Diners Club card number.\n\n    Examples:\n        &gt;&gt;&gt; diners('3056930009020004')\n        # Output: True\n        &gt;&gt;&gt; diners('4242424242424242')\n        # Output: ValidationError(func=diners, args={'value': '4242424242424242'})\n\n    Args:\n        value:\n            Diners Club card number string to validate\n\n    Returns:\n        (Literal[True]):\n            If `value` is a valid Diners Club card number.\n        (ValidationError):\n            If `value` is an invalid Diners Club card number.\n\n    &gt; *New in version 0.15.0*.\n    \"\"\"\n    pattern = re.compile(r\"^(30|36|38|39)\")\n    return card_number(value) and len(value) in {14, 16} and pattern.match(value)\n</code></pre>"},{"location":"references/card/#validators.card.discover","title":"<code>validators.card.discover(value)</code>","text":"<p>Return whether or not given value is a valid Discover card number.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; discover('6011111111111117')\n# Output: True\n&gt;&gt;&gt; discover('4242424242424242')\n# Output: ValidationError(func=discover, args={'value': '4242424242424242'})\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>Discover card number string to validate</p> required <p>Returns:</p> Type Description <code>Literal[True]</code> <p>If <code>value</code> is a valid Discover card number.</p> <code>ValidationError</code> <p>If <code>value</code> is an invalid Discover card number.</p> <p>New in version 0.15.0.</p> Source code in <code>src/validators/card.py</code> <pre><code>@validator\ndef discover(value: str, /):\n    \"\"\"Return whether or not given value is a valid Discover card number.\n\n    Examples:\n        &gt;&gt;&gt; discover('6011111111111117')\n        # Output: True\n        &gt;&gt;&gt; discover('4242424242424242')\n        # Output: ValidationError(func=discover, args={'value': '4242424242424242'})\n\n    Args:\n        value:\n            Discover card number string to validate\n\n    Returns:\n        (Literal[True]):\n            If `value` is a valid Discover card number.\n        (ValidationError):\n            If `value` is an invalid Discover card number.\n\n    &gt; *New in version 0.15.0*.\n    \"\"\"\n    pattern = re.compile(r\"^(60|64|65)\")\n    return card_number(value) and len(value) == 16 and pattern.match(value)\n</code></pre>"},{"location":"references/card/#validators.card.jcb","title":"<code>validators.card.jcb(value)</code>","text":"<p>Return whether or not given value is a valid JCB card number.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; jcb('3566002020360505')\n# Output: True\n&gt;&gt;&gt; jcb('4242424242424242')\n# Output: ValidationError(func=jcb, args={'value': '4242424242424242'})\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>JCB card number string to validate</p> required <p>Returns:</p> Type Description <code>Literal[True]</code> <p>If <code>value</code> is a valid JCB card number.</p> <code>ValidationError</code> <p>If <code>value</code> is an invalid JCB card number.</p> <p>New in version 0.15.0.</p> Source code in <code>src/validators/card.py</code> <pre><code>@validator\ndef jcb(value: str, /):\n    \"\"\"Return whether or not given value is a valid JCB card number.\n\n    Examples:\n        &gt;&gt;&gt; jcb('3566002020360505')\n        # Output: True\n        &gt;&gt;&gt; jcb('4242424242424242')\n        # Output: ValidationError(func=jcb, args={'value': '4242424242424242'})\n\n    Args:\n        value:\n            JCB card number string to validate\n\n    Returns:\n        (Literal[True]):\n            If `value` is a valid JCB card number.\n        (ValidationError):\n            If `value` is an invalid JCB card number.\n\n    &gt; *New in version 0.15.0*.\n    \"\"\"\n    pattern = re.compile(r\"^35\")\n    return card_number(value) and len(value) == 16 and pattern.match(value)\n</code></pre>"},{"location":"references/card/#validators.card.mastercard","title":"<code>validators.card.mastercard(value)</code>","text":"<p>Return whether or not given value is a valid Mastercard card number.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; mastercard('5555555555554444')\n# Output: True\n&gt;&gt;&gt; mastercard('4242424242424242')\n# Output: ValidationError(func=mastercard, args={'value': '4242424242424242'})\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>Mastercard card number string to validate</p> required <p>Returns:</p> Type Description <code>Literal[True]</code> <p>If <code>value</code> is a valid Mastercard card number.</p> <code>ValidationError</code> <p>If <code>value</code> is an invalid Mastercard card number.</p> <p>New in version 0.15.0.</p> Source code in <code>src/validators/card.py</code> <pre><code>@validator\ndef mastercard(value: str, /):\n    \"\"\"Return whether or not given value is a valid Mastercard card number.\n\n    Examples:\n        &gt;&gt;&gt; mastercard('5555555555554444')\n        # Output: True\n        &gt;&gt;&gt; mastercard('4242424242424242')\n        # Output: ValidationError(func=mastercard, args={'value': '4242424242424242'})\n\n    Args:\n        value:\n            Mastercard card number string to validate\n\n    Returns:\n        (Literal[True]):\n            If `value` is a valid Mastercard card number.\n        (ValidationError):\n            If `value` is an invalid Mastercard card number.\n\n    &gt; *New in version 0.15.0*.\n    \"\"\"\n    pattern = re.compile(r\"^(51|52|53|54|55|22|23|24|25|26|27)\")\n    return card_number(value) and len(value) == 16 and pattern.match(value)\n</code></pre>"},{"location":"references/card/#validators.card.unionpay","title":"<code>validators.card.unionpay(value)</code>","text":"<p>Return whether or not given value is a valid UnionPay card number.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; unionpay('6200000000000005')\n# Output: True\n&gt;&gt;&gt; unionpay('4242424242424242')\n# Output: ValidationError(func=unionpay, args={'value': '4242424242424242'})\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>UnionPay card number string to validate</p> required <p>Returns:</p> Type Description <code>Literal[True]</code> <p>If <code>value</code> is a valid UnionPay card number.</p> <code>ValidationError</code> <p>If <code>value</code> is an invalid UnionPay card number.</p> <p>New in version 0.15.0.</p> Source code in <code>src/validators/card.py</code> <pre><code>@validator\ndef unionpay(value: str, /):\n    \"\"\"Return whether or not given value is a valid UnionPay card number.\n\n    Examples:\n        &gt;&gt;&gt; unionpay('6200000000000005')\n        # Output: True\n        &gt;&gt;&gt; unionpay('4242424242424242')\n        # Output: ValidationError(func=unionpay, args={'value': '4242424242424242'})\n\n    Args:\n        value:\n            UnionPay card number string to validate\n\n    Returns:\n        (Literal[True]):\n            If `value` is a valid UnionPay card number.\n        (ValidationError):\n            If `value` is an invalid UnionPay card number.\n\n    &gt; *New in version 0.15.0*.\n    \"\"\"\n    pattern = re.compile(r\"^62\")\n    return card_number(value) and len(value) == 16 and pattern.match(value)\n</code></pre>"},{"location":"references/card/#validators.card.visa","title":"<code>validators.card.visa(value)</code>","text":"<p>Return whether or not given value is a valid Visa card number.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; visa('4242424242424242')\n# Output: True\n&gt;&gt;&gt; visa('2223003122003222')\n# Output: ValidationError(func=visa, args={'value': '2223003122003222'})\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>Visa card number string to validate</p> required <p>Returns:</p> Type Description <code>Literal[True]</code> <p>If <code>value</code> is a valid Visa card number.</p> <code>ValidationError</code> <p>If <code>value</code> is an invalid Visa card number.</p> <p>New in version 0.15.0.</p> Source code in <code>src/validators/card.py</code> <pre><code>@validator\ndef visa(value: str, /):\n    \"\"\"Return whether or not given value is a valid Visa card number.\n\n    Examples:\n        &gt;&gt;&gt; visa('4242424242424242')\n        # Output: True\n        &gt;&gt;&gt; visa('2223003122003222')\n        # Output: ValidationError(func=visa, args={'value': '2223003122003222'})\n\n    Args:\n        value:\n            Visa card number string to validate\n\n    Returns:\n        (Literal[True]):\n            If `value` is a valid Visa card number.\n        (ValidationError):\n            If `value` is an invalid Visa card number.\n\n    &gt; *New in version 0.15.0*.\n    \"\"\"\n    pattern = re.compile(r\"^4\")\n    return card_number(value) and len(value) == 16 and pattern.match(value)\n</code></pre>"},{"location":"references/country_code/","title":"country_code","text":""},{"location":"references/country_code/#validators.country_code.country_code","title":"<code>validators.country_code.country_code(value, /, *, iso_format='auto')</code>","text":"<p>Validates given country code.</p> <p>This performs a case-sensitive ISO 3166 country code validation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; country_code('GB', iso_format='alpha3')\n# Output: False\n&gt;&gt;&gt; country_code('USA')\n# Output: True\n&gt;&gt;&gt; country_code('840', iso_format='numeric')\n# Output: True\n&gt;&gt;&gt; country_code('iN', iso_format='alpha2')\n# Output: False\n&gt;&gt;&gt; country_code('ZWE', iso_format='alpha3')\n# Output: True\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>Country code string to validate.</p> required <code>iso_format</code> <code>str</code> <p>ISO format to be used. Available options are: <code>auto</code>, <code>alpha2</code>, <code>alpha3</code> and <code>numeric</code>.</p> <code>'auto'</code> <p>Returns:</p> Type Description <code>Literal[True]</code> <p>If <code>value</code> is a valid country code.</p> <code>ValidationError</code> <p>If <code>value</code> is an invalid country code.</p> Source code in <code>src/validators/country_code.py</code> <pre><code>@validator\ndef country_code(value: str, /, *, iso_format: str = \"auto\"):\n    \"\"\"Validates given country code.\n\n    This performs a case-sensitive [ISO 3166][1] country code validation.\n\n    [1]: https://www.iso.org/iso-3166-country-codes.html\n\n    Examples:\n        &gt;&gt;&gt; country_code('GB', iso_format='alpha3')\n        # Output: False\n        &gt;&gt;&gt; country_code('USA')\n        # Output: True\n        &gt;&gt;&gt; country_code('840', iso_format='numeric')\n        # Output: True\n        &gt;&gt;&gt; country_code('iN', iso_format='alpha2')\n        # Output: False\n        &gt;&gt;&gt; country_code('ZWE', iso_format='alpha3')\n        # Output: True\n\n    Args:\n        value:\n            Country code string to validate.\n        iso_format:\n            ISO format to be used. Available options are:\n            `auto`, `alpha2`, `alpha3` and `numeric`.\n\n    Returns:\n        (Literal[True]):\n            If `value` is a valid country code.\n        (ValidationError):\n            If `value` is an invalid country code.\n    \"\"\"\n    if not value:\n        return False\n\n    if not (1 &lt; len(value) &lt; 4):\n        return False\n\n    if iso_format == \"auto\" and (iso_format := get_code_type(value)) == \"invalid\":\n        return False\n\n    if iso_format == \"alpha2\":\n        return value in alpha_2\n    if iso_format == \"alpha3\":\n        return value in alpha_3\n    return value in numeric if iso_format == \"numeric\" else False\n</code></pre>"},{"location":"references/domain/","title":"domain","text":""},{"location":"references/domain/#validators.domain.domain","title":"<code>validators.domain.domain(value, /, *, rfc_1034=False, rfc_2782=False)</code>","text":"<p>Return whether or not given value is a valid domain.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; domain('example.com')\n# Output: True\n&gt;&gt;&gt; domain('example.com/')\n# Output: ValidationError(func=domain, ...)\n&gt;&gt;&gt; # Supports IDN domains as well::\n&gt;&gt;&gt; domain('xn----gtbspbbmkef.xn--p1ai')\n# Output: True\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>Domain string to validate.</p> required <code>rfc_1034</code> <code>bool</code> <p>Allow trailing dot in domain name. Ref: RFC 1034.</p> <code>False</code> <code>rfc_2782</code> <code>bool</code> <p>Domain name is of type service record. Ref: RFC 2782.</p> <code>False</code> <p>Returns:</p> Type Description <code>Literal[True]</code> <p>If <code>value</code> is a valid domain name.</p> <code>ValidationError</code> <p>If <code>value</code> is an invalid domain name.</p> Note <ul> <li>In version 0.10.0:<ul> <li>Added support for internationalized domain name (IDN) validation.</li> </ul> </li> </ul> <p>New in version 0.9.0.</p> Source code in <code>src/validators/domain.py</code> <pre><code>@validator\ndef domain(value: str, /, *, rfc_1034: bool = False, rfc_2782: bool = False):\n    \"\"\"Return whether or not given value is a valid domain.\n\n    Examples:\n        &gt;&gt;&gt; domain('example.com')\n        # Output: True\n        &gt;&gt;&gt; domain('example.com/')\n        # Output: ValidationError(func=domain, ...)\n        &gt;&gt;&gt; # Supports IDN domains as well::\n        &gt;&gt;&gt; domain('xn----gtbspbbmkef.xn--p1ai')\n        # Output: True\n\n    Args:\n        value:\n            Domain string to validate.\n        rfc_1034:\n            Allow trailing dot in domain name.\n            Ref: [RFC 1034](https://www.rfc-editor.org/rfc/rfc1034).\n        rfc_2782:\n            Domain name is of type service record.\n            Ref: [RFC 2782](https://www.rfc-editor.org/rfc/rfc2782).\n\n\n    Returns:\n        (Literal[True]):\n            If `value` is a valid domain name.\n        (ValidationError):\n            If `value` is an invalid domain name.\n\n    Note:\n        - *In version 0.10.0*:\n            - Added support for internationalized domain name (IDN) validation.\n\n    &gt; *New in version 0.9.0*.\n    \"\"\"\n    if not value:\n        return False\n    try:\n        return not re.search(r\"\\s\", value) and re.match(\n            # First character of the domain\n            rf\"^(?:[a-zA-Z0-9{'_'if rfc_2782 else ''}]\"\n            # Sub domain + hostname\n            + r\"(?:[a-zA-Z0-9-_]{0,61}[A-Za-z0-9])?\\.)\"\n            # First 61 characters of the gTLD\n            + r\"+[A-Za-z0-9][A-Za-z0-9-_]{0,61}\"\n            # Last character of the gTLD\n            + rf\"[A-Za-z]{r'.$' if rfc_1034 else r'$'}\",\n            value.encode(\"idna\").decode(\"utf-8\"),\n            re.IGNORECASE,\n        )\n    except UnicodeError:\n        return False\n</code></pre>"},{"location":"references/email/","title":"email","text":""},{"location":"references/email/#validators.email.email","title":"<code>validators.email.email(value, /, *, ipv6_address=False, ipv4_address=False, simple_host=False, rfc_1034=False, rfc_2782=False)</code>","text":"<p>Validate an email address.</p> <p>This was inspired from Django's email validator. Also ref: RFC 1034, RFC 5321 and RFC 5322.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; email('someone@example.com')\n# Output: True\n&gt;&gt;&gt; email('bogus@@')\n# Output: ValidationError(email=email, args={'value': 'bogus@@'})\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>eMail string to validate.</p> required <code>ipv6_address</code> <code>bool</code> <p>When the domain part is an IPv6 address.</p> <code>False</code> <code>ipv4_address</code> <code>bool</code> <p>When the domain part is an IPv4 address.</p> <code>False</code> <code>simple_host</code> <code>bool</code> <p>When the domain part is a simple hostname.</p> <code>False</code> <code>rfc_1034</code> <code>bool</code> <p>Allow trailing dot in domain name. Ref: RFC 1034.</p> <code>False</code> <code>rfc_2782</code> <code>bool</code> <p>Domain name is of type service record. Ref: RFC 2782.</p> <code>False</code> <p>Returns:</p> Type Description <code>Literal[True]</code> <p>If <code>value</code> is a valid eMail.</p> <code>ValidationError</code> <p>If <code>value</code> is an invalid eMail.</p> <p>New in version 0.1.0.</p> Source code in <code>src/validators/email.py</code> <pre><code>@validator\ndef email(\n    value: str,\n    /,\n    *,\n    ipv6_address: bool = False,\n    ipv4_address: bool = False,\n    simple_host: bool = False,\n    rfc_1034: bool = False,\n    rfc_2782: bool = False,\n):\n    \"\"\"Validate an email address.\n\n    This was inspired from [Django's email validator][1].\n    Also ref: [RFC 1034][2], [RFC 5321][3] and [RFC 5322][4].\n\n    [1]: https://github.com/django/django/blob/main/django/core/validators.py#L174\n    [2]: https://www.rfc-editor.org/rfc/rfc1034\n    [3]: https://www.rfc-editor.org/rfc/rfc5321\n    [4]: https://www.rfc-editor.org/rfc/rfc5322\n\n    Examples:\n        &gt;&gt;&gt; email('someone@example.com')\n        # Output: True\n        &gt;&gt;&gt; email('bogus@@')\n        # Output: ValidationError(email=email, args={'value': 'bogus@@'})\n\n    Args:\n        value:\n            eMail string to validate.\n        ipv6_address:\n            When the domain part is an IPv6 address.\n        ipv4_address:\n            When the domain part is an IPv4 address.\n        simple_host:\n            When the domain part is a simple hostname.\n        rfc_1034:\n            Allow trailing dot in domain name.\n            Ref: [RFC 1034](https://www.rfc-editor.org/rfc/rfc1034).\n        rfc_2782:\n            Domain name is of type service record.\n            Ref: [RFC 2782](https://www.rfc-editor.org/rfc/rfc2782).\n\n    Returns:\n        (Literal[True]):\n            If `value` is a valid eMail.\n        (ValidationError):\n            If `value` is an invalid eMail.\n\n    &gt; *New in version 0.1.0*.\n    \"\"\"\n    if not value or value.count(\"@\") != 1:\n        return False\n\n    username_part, domain_part = value.rsplit(\"@\", 1)\n\n    if len(username_part) &gt; 64 or len(domain_part) &gt; 253:\n        # ref: RFC 1034 and 5231\n        return False\n\n    if ipv6_address or ipv4_address:\n        if domain_part.startswith(\"[\") and domain_part.endswith(\"]\"):\n            # ref: RFC 5321\n            domain_part = domain_part.lstrip(\"[\").rstrip(\"]\")\n        else:\n            return False\n\n    return (\n        bool(\n            hostname(\n                domain_part,\n                skip_ipv6_addr=not ipv6_address,\n                skip_ipv4_addr=not ipv4_address,\n                may_have_port=False,\n                maybe_simple=simple_host,\n                rfc_1034=rfc_1034,\n                rfc_2782=rfc_2782,\n            )\n        )\n        if re.match(\n            # dot-atom\n            r\"(^[-!#$%&amp;'*+/=?^_`{}|~0-9A-Z]+(\\.[-!#$%&amp;'*+/=?^_`{}|~0-9A-Z]+)*$\"\n            # quoted-string\n            + r'|^\"([\\001-\\010\\013\\014\\016-\\037!#-\\[\\]-\\177]|\\\\[\\001-\\011\\013\\014\\016-\\177])*\"$)',\n            username_part,\n            re.IGNORECASE,\n        )\n        else False\n    )\n</code></pre>"},{"location":"references/hashes/","title":"hashes","text":""},{"location":"references/hashes/#validators.hashes.md5","title":"<code>validators.hashes.md5(value)</code>","text":"<p>Return whether or not given value is a valid MD5 hash.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; md5('d41d8cd98f00b204e9800998ecf8427e')\n# Output: True\n&gt;&gt;&gt; md5('900zz11')\n# Output: ValidationError(func=md5, args={'value': '900zz11'})\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>MD5 string to validate.</p> required <p>Returns:</p> Type Description <code>Literal[True]</code> <p>If <code>value</code> is a valid MD5 hash.</p> <code>ValidationError</code> <p>If <code>value</code> is an invalid MD5 hash.</p> <p>New in version 0.12.1</p> Source code in <code>src/validators/hashes.py</code> <pre><code>@validator\ndef md5(value: str, /):\n    \"\"\"Return whether or not given value is a valid MD5 hash.\n\n    Examples:\n        &gt;&gt;&gt; md5('d41d8cd98f00b204e9800998ecf8427e')\n        # Output: True\n        &gt;&gt;&gt; md5('900zz11')\n        # Output: ValidationError(func=md5, args={'value': '900zz11'})\n\n    Args:\n        value:\n            MD5 string to validate.\n\n    Returns:\n        (Literal[True]):\n            If `value` is a valid MD5 hash.\n        (ValidationError):\n            If `value` is an invalid MD5 hash.\n\n    &gt; *New in version 0.12.1*\n    \"\"\"\n    return re.match(r\"^[0-9a-f]{32}$\", value, re.IGNORECASE) if value else False\n</code></pre>"},{"location":"references/hashes/#validators.hashes.sha1","title":"<code>validators.hashes.sha1(value)</code>","text":"<p>Return whether or not given value is a valid SHA1 hash.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; sha1('da39a3ee5e6b4b0d3255bfef95601890afd80709')\n# Output: True\n&gt;&gt;&gt; sha1('900zz11')\n# Output: ValidationError(func=sha1, args={'value': '900zz11'})\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>SHA1 string to validate.</p> required <p>Returns:</p> Type Description <code>Literal[True]</code> <p>If <code>value</code> is a valid SHA1 hash.</p> <code>ValidationError</code> <p>If <code>value</code> is an invalid SHA1 hash.</p> <p>New in version 0.12.1</p> Source code in <code>src/validators/hashes.py</code> <pre><code>@validator\ndef sha1(value: str, /):\n    \"\"\"Return whether or not given value is a valid SHA1 hash.\n\n    Examples:\n        &gt;&gt;&gt; sha1('da39a3ee5e6b4b0d3255bfef95601890afd80709')\n        # Output: True\n        &gt;&gt;&gt; sha1('900zz11')\n        # Output: ValidationError(func=sha1, args={'value': '900zz11'})\n\n    Args:\n        value:\n            SHA1 string to validate.\n\n    Returns:\n        (Literal[True]):\n            If `value` is a valid SHA1 hash.\n        (ValidationError):\n            If `value` is an invalid SHA1 hash.\n\n    &gt; *New in version 0.12.1*\n    \"\"\"\n    return re.match(r\"^[0-9a-f]{40}$\", value, re.IGNORECASE) if value else False\n</code></pre>"},{"location":"references/hashes/#validators.hashes.sha224","title":"<code>validators.hashes.sha224(value)</code>","text":"<p>Return whether or not given value is a valid SHA224 hash.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; sha224('d14a028c2a3a2bc9476102bb288234c415a2b01f828ea62ac5b3e42f')\n# Output: True\n&gt;&gt;&gt; sha224('900zz11')\n# Output: ValidationError(func=sha224, args={'value': '900zz11'})\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>SHA224 string to validate.</p> required <p>Returns:</p> Type Description <code>Literal[True]</code> <p>If <code>value</code> is a valid SHA224 hash.</p> <code>ValidationError</code> <p>If <code>value</code> is an invalid SHA224 hash.</p> <p>New in version 0.12.1</p> Source code in <code>src/validators/hashes.py</code> <pre><code>@validator\ndef sha224(value: str, /):\n    \"\"\"Return whether or not given value is a valid SHA224 hash.\n\n    Examples:\n        &gt;&gt;&gt; sha224('d14a028c2a3a2bc9476102bb288234c415a2b01f828ea62ac5b3e42f')\n        # Output: True\n        &gt;&gt;&gt; sha224('900zz11')\n        # Output: ValidationError(func=sha224, args={'value': '900zz11'})\n\n    Args:\n        value:\n            SHA224 string to validate.\n\n    Returns:\n        (Literal[True]):\n            If `value` is a valid SHA224 hash.\n        (ValidationError):\n            If `value` is an invalid SHA224 hash.\n\n    &gt; *New in version 0.12.1*\n    \"\"\"\n    return re.match(r\"^[0-9a-f]{56}$\", value, re.IGNORECASE) if value else False\n</code></pre>"},{"location":"references/hashes/#validators.hashes.sha256","title":"<code>validators.hashes.sha256(value)</code>","text":"<p>Return whether or not given value is a valid SHA256 hash.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; sha256(\n...     'e3b0c44298fc1c149afbf4c8996fb924'\n...     '27ae41e4649b934ca495991b7852b855'\n... )\n# Output: True\n&gt;&gt;&gt; sha256('900zz11')\n# Output: ValidationError(func=sha256, args={'value': '900zz11'})\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>SHA256 string to validate.</p> required <p>Returns:</p> Type Description <code>Literal[True]</code> <p>If <code>value</code> is a valid SHA256 hash.</p> <code>ValidationError</code> <p>If <code>value</code> is an invalid SHA256 hash.</p> <p>New in version 0.12.1</p> Source code in <code>src/validators/hashes.py</code> <pre><code>@validator\ndef sha256(value: str, /):\n    \"\"\"Return whether or not given value is a valid SHA256 hash.\n\n    Examples:\n        &gt;&gt;&gt; sha256(\n        ...     'e3b0c44298fc1c149afbf4c8996fb924'\n        ...     '27ae41e4649b934ca495991b7852b855'\n        ... )\n        # Output: True\n        &gt;&gt;&gt; sha256('900zz11')\n        # Output: ValidationError(func=sha256, args={'value': '900zz11'})\n\n    Args:\n        value:\n            SHA256 string to validate.\n\n    Returns:\n        (Literal[True]):\n            If `value` is a valid SHA256 hash.\n        (ValidationError):\n            If `value` is an invalid SHA256 hash.\n\n    &gt; *New in version 0.12.1*\n    \"\"\"\n    return re.match(r\"^[0-9a-f]{64}$\", value, re.IGNORECASE) if value else False\n</code></pre>"},{"location":"references/hashes/#validators.hashes.sha512","title":"<code>validators.hashes.sha512(value)</code>","text":"<p>Return whether or not given value is a valid SHA512 hash.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; sha512(\n...     'cf83e1357eefb8bdf1542850d66d8007d620e4050b5715dc83f4a921d36ce'\n...     '9ce47d0d13c5d85f2b0ff8318d2877eec2f63b931bd47417a81a538327af9'\n...     '27da3e'\n... )\n# Output: True\n&gt;&gt;&gt; sha512('900zz11')\n# Output: ValidationError(func=sha512, args={'value': '900zz11'})\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>SHA512 string to validate.</p> required <p>Returns:</p> Type Description <code>Literal[True]</code> <p>If <code>value</code> is a valid SHA512 hash.</p> <code>ValidationError</code> <p>If <code>value</code> is an invalid SHA512 hash.</p> <p>New in version 0.12.1</p> Source code in <code>src/validators/hashes.py</code> <pre><code>@validator\ndef sha512(value: str, /):\n    \"\"\"Return whether or not given value is a valid SHA512 hash.\n\n    Examples:\n        &gt;&gt;&gt; sha512(\n        ...     'cf83e1357eefb8bdf1542850d66d8007d620e4050b5715dc83f4a921d36ce'\n        ...     '9ce47d0d13c5d85f2b0ff8318d2877eec2f63b931bd47417a81a538327af9'\n        ...     '27da3e'\n        ... )\n        # Output: True\n        &gt;&gt;&gt; sha512('900zz11')\n        # Output: ValidationError(func=sha512, args={'value': '900zz11'})\n\n    Args:\n        value:\n            SHA512 string to validate.\n\n    Returns:\n        (Literal[True]):\n            If `value` is a valid SHA512 hash.\n        (ValidationError):\n            If `value` is an invalid SHA512 hash.\n\n    &gt; *New in version 0.12.1*\n    \"\"\"\n    return re.match(r\"^[0-9a-f]{128}$\", value, re.IGNORECASE) if value else False\n</code></pre>"},{"location":"references/hostname/","title":"hostname","text":""},{"location":"references/hostname/#validators.hostname.hostname","title":"<code>validators.hostname.hostname(value, /, *, skip_ipv6_addr=False, skip_ipv4_addr=False, may_have_port=True, maybe_simple=True, rfc_1034=False, rfc_2782=False)</code>","text":"<p>Return whether or not given value is a valid hostname.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; hostname(\"ubuntu-pc:443\")\n# Output: True\n&gt;&gt;&gt; hostname(\"this-pc\")\n# Output: True\n&gt;&gt;&gt; hostname(\"xn----gtbspbbmkef.xn--p1ai:65535\")\n# Output: True\n&gt;&gt;&gt; hostname(\"_example.com\")\n# Output: True\n&gt;&gt;&gt; hostname(\"123.5.77.88:31000\")\n# Output: True\n&gt;&gt;&gt; hostname(\"12.12.12.12\")\n# Output: True\n&gt;&gt;&gt; hostname(\"[::1]:22\")\n# Output: True\n&gt;&gt;&gt; hostname(\"dead:beef:0:0:0:0000:42:1\")\n# Output: True\n&gt;&gt;&gt; hostname(\"[0:0:0:0:0:ffff:1.2.3.4]:-65538\")\n# Output: ValidationError(func=hostname, ...)\n&gt;&gt;&gt; hostname(\"[0:&amp;:b:c:@:e:f::]:9999\")\n# Output: ValidationError(func=hostname, ...)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>Hostname string to validate.</p> required <code>skip_ipv6_addr</code> <code>bool</code> <p>When hostname string cannot be an IPv6 address.</p> <code>False</code> <code>skip_ipv4_addr</code> <code>bool</code> <p>When hostname string cannot be an IPv4 address.</p> <code>False</code> <code>may_have_port</code> <code>bool</code> <p>Hostname string may contain port number.</p> <code>True</code> <code>maybe_simple</code> <code>bool</code> <p>Hostname string maybe only hyphens and alpha-numerals.</p> <code>True</code> <code>rfc_1034</code> <code>bool</code> <p>Allow trailing dot in domain/host name. Ref: RFC 1034.</p> <code>False</code> <code>rfc_2782</code> <code>bool</code> <p>Domain/Host name is of type service record. Ref: RFC 2782.</p> <code>False</code> <p>Returns:</p> Type Description <code>Literal[True]</code> <p>If <code>value</code> is a valid hostname.</p> <code>ValidationError</code> <p>If <code>value</code> is an invalid hostname.</p> <p>New in version 0.21.0.</p> Source code in <code>src/validators/hostname.py</code> <pre><code>@validator\ndef hostname(\n    value: str,\n    /,\n    *,\n    skip_ipv6_addr: bool = False,\n    skip_ipv4_addr: bool = False,\n    may_have_port: bool = True,\n    maybe_simple: bool = True,\n    rfc_1034: bool = False,\n    rfc_2782: bool = False,\n):\n    \"\"\"Return whether or not given value is a valid hostname.\n\n    Examples:\n        &gt;&gt;&gt; hostname(\"ubuntu-pc:443\")\n        # Output: True\n        &gt;&gt;&gt; hostname(\"this-pc\")\n        # Output: True\n        &gt;&gt;&gt; hostname(\"xn----gtbspbbmkef.xn--p1ai:65535\")\n        # Output: True\n        &gt;&gt;&gt; hostname(\"_example.com\")\n        # Output: True\n        &gt;&gt;&gt; hostname(\"123.5.77.88:31000\")\n        # Output: True\n        &gt;&gt;&gt; hostname(\"12.12.12.12\")\n        # Output: True\n        &gt;&gt;&gt; hostname(\"[::1]:22\")\n        # Output: True\n        &gt;&gt;&gt; hostname(\"dead:beef:0:0:0:0000:42:1\")\n        # Output: True\n        &gt;&gt;&gt; hostname(\"[0:0:0:0:0:ffff:1.2.3.4]:-65538\")\n        # Output: ValidationError(func=hostname, ...)\n        &gt;&gt;&gt; hostname(\"[0:&amp;:b:c:@:e:f::]:9999\")\n        # Output: ValidationError(func=hostname, ...)\n\n    Args:\n        value:\n            Hostname string to validate.\n        skip_ipv6_addr:\n            When hostname string cannot be an IPv6 address.\n        skip_ipv4_addr:\n            When hostname string cannot be an IPv4 address.\n        may_have_port:\n            Hostname string may contain port number.\n        maybe_simple:\n            Hostname string maybe only hyphens and alpha-numerals.\n        rfc_1034:\n            Allow trailing dot in domain/host name.\n            Ref: [RFC 1034](https://www.rfc-editor.org/rfc/rfc1034).\n        rfc_2782:\n            Domain/Host name is of type service record.\n            Ref: [RFC 2782](https://www.rfc-editor.org/rfc/rfc2782).\n\n    Returns:\n        (Literal[True]):\n            If `value` is a valid hostname.\n        (ValidationError):\n            If `value` is an invalid hostname.\n\n    &gt; *New in version 0.21.0*.\n    \"\"\"\n    if not value:\n        return False\n\n    if may_have_port and (host_seg := _port_validator(value)):\n        return (\n            (_simple_hostname_regex().match(host_seg) if maybe_simple else False)\n            or domain(host_seg, rfc_1034=rfc_1034, rfc_2782=rfc_2782)\n            or (False if skip_ipv4_addr else ipv4(host_seg, cidr=False))\n            or (False if skip_ipv6_addr else ipv6(host_seg, cidr=False))\n        )\n\n    return (\n        (_simple_hostname_regex().match(value) if maybe_simple else False)\n        or domain(value, rfc_1034=rfc_1034, rfc_2782=rfc_2782)\n        or (False if skip_ipv4_addr else ipv4(value, cidr=False))\n        or (False if skip_ipv6_addr else ipv6(value, cidr=False))\n    )\n</code></pre>"},{"location":"references/i18n/","title":"i18n","text":""},{"location":"references/i18n/#validators.i18n.es_cif","title":"<code>validators.i18n.es_cif(value)</code>","text":"<p>Validate a Spanish CIF.</p> <p>Each company in Spain prior to 2008 had a distinct CIF and has been discontinued. For more information see wikipedia.org/cif.</p> <p>The new replacement is to use NIF for absolutely everything. The issue is that there are \"types\" of NIFs now: company, person [citizen or resident] all distinguished by the first character of the DOI. For this reason we will continue to call CIFs NIFs, that are used for companies.</p> <p>This validator is based on generadordni.es.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; es_cif('B25162520')\n# Output: True\n&gt;&gt;&gt; es_cif('B25162529')\n# Output: ValidationError(func=es_cif, args=...)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>DOI string which is to be validated.</p> required <p>Returns:</p> Type Description <code>Literal[True]</code> <p>If <code>value</code> is a valid DOI string.</p> <code>ValidationError</code> <p>If <code>value</code> is an invalid DOI string.</p> <p>New in version 0.13.0.</p> Source code in <code>src/validators/i18n/es.py</code> <pre><code>@validator\ndef es_cif(value: str, /):\n    \"\"\"Validate a Spanish CIF.\n\n    Each company in Spain prior to 2008 had a distinct CIF and has been\n    discontinued. For more information see [wikipedia.org/cif][1].\n\n    The new replacement is to use NIF for absolutely everything. The issue is\n    that there are \"types\" of NIFs now: company, person [citizen or resident]\n    all distinguished by the first character of the DOI. For this reason we\n    will continue to call CIFs NIFs, that are used for companies.\n\n    This validator is based on [generadordni.es][2].\n\n    [1]: https://es.wikipedia.org/wiki/C%C3%B3digo_de_identificaci%C3%B3n_fiscal\n    [2]: https://generadordni.es/\n\n    Examples:\n        &gt;&gt;&gt; es_cif('B25162520')\n        # Output: True\n        &gt;&gt;&gt; es_cif('B25162529')\n        # Output: ValidationError(func=es_cif, args=...)\n\n    Args:\n        value:\n            DOI string which is to be validated.\n\n    Returns:\n        (Literal[True]):\n            If `value` is a valid DOI string.\n        (ValidationError):\n            If `value` is an invalid DOI string.\n\n    &gt; *New in version 0.13.0*.\n    \"\"\"\n    if not value or len(value) != 9:\n        return False\n    value = value.upper()\n    table = \"JABCDEFGHI\"\n    first_chr = value[0]\n    doi_body = value[1:8]\n    control = value[8]\n    if not doi_body.isdigit():\n        return False\n    res = (\n        10\n        - sum(\n            # Multiply each positionally even doi\n            # digit by 2 and sum it all together\n            sum(map(int, str(int(char) * 2))) if index % 2 == 0 else int(char)\n            for index, char in enumerate(doi_body)\n        )\n        % 10\n    ) % 10\n    if first_chr in \"ABEH\":  # Number type\n        return str(res) == control\n    if first_chr in \"PSQW\":  # Letter type\n        return table[res] == control\n    return control in {str(res), table[res]} if first_chr in \"CDFGJNRUV\" else False\n</code></pre>"},{"location":"references/i18n/#validators.i18n.es_doi","title":"<code>validators.i18n.es_doi(value)</code>","text":"<p>Validate a Spanish DOI.</p> <p>A DOI in spain is all NIF / CIF / NIE / DNI -- a digital ID. For more information see wikipedia.org/doi. This validator is based on generadordni.es.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; es_doi('X0095892M')\n# Output: True\n&gt;&gt;&gt; es_doi('X0095892X')\n# Output: ValidationError(func=es_doi, args=...)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>DOI string which is to be validated.</p> required <p>Returns:</p> Type Description <code>Literal[True]</code> <p>If <code>value</code> is a valid DOI string.</p> <code>ValidationError</code> <p>If <code>value</code> is an invalid DOI string.</p> <p>New in version 0.13.0.</p> Source code in <code>src/validators/i18n/es.py</code> <pre><code>@validator\ndef es_doi(value: str, /):\n    \"\"\"Validate a Spanish DOI.\n\n    A DOI in spain is all NIF / CIF / NIE / DNI -- a digital ID.\n    For more information see [wikipedia.org/doi][1]. This validator\n    is based on [generadordni.es][2].\n\n    [1]: https://es.wikipedia.org/wiki/Identificador_de_objeto_digital\n    [2]: https://generadordni.es/\n\n    Examples:\n        &gt;&gt;&gt; es_doi('X0095892M')\n        # Output: True\n        &gt;&gt;&gt; es_doi('X0095892X')\n        # Output: ValidationError(func=es_doi, args=...)\n\n    Args:\n        value:\n            DOI string which is to be validated.\n\n    Returns:\n        (Literal[True]):\n            If `value` is a valid DOI string.\n        (ValidationError):\n            If `value` is an invalid DOI string.\n\n    &gt; *New in version 0.13.0*.\n    \"\"\"\n    return es_nie(value) or es_nif(value) or es_cif(value)\n</code></pre>"},{"location":"references/i18n/#validators.i18n.es_nie","title":"<code>validators.i18n.es_nie(value)</code>","text":"<p>Validate a Spanish NIE.</p> <p>The NIE is a tax identification number in Spain, known in Spanish as the NIE, or more formally the N\u00famero de identidad de extranjero. For more information see wikipedia.org/nie. This validator is based on generadordni.es.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; es_nie('X0095892M')\n# Output: True\n&gt;&gt;&gt; es_nie('X0095892X')\n# Output: ValidationError(func=es_nie, args=...)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>DOI string which is to be validated.</p> required <p>Returns:</p> Type Description <code>Literal[True]</code> <p>If <code>value</code> is a valid DOI string.</p> <code>ValidationError</code> <p>If <code>value</code> is an invalid DOI string.</p> <p>New in version 0.13.0.</p> Source code in <code>src/validators/i18n/es.py</code> <pre><code>@validator\ndef es_nie(value: str, /):\n    \"\"\"Validate a Spanish NIE.\n\n    The NIE is a tax identification number in Spain, known in Spanish\n    as the NIE, or more formally the N\u00famero de identidad de extranjero.\n    For more information see [wikipedia.org/nie][1]. This validator\n    is based on [generadordni.es][2].\n\n    [1]: https://es.wikipedia.org/wiki/N%C3%BAmero_de_identidad_de_extranjero\n    [2]: https://generadordni.es/\n\n    Examples:\n        &gt;&gt;&gt; es_nie('X0095892M')\n        # Output: True\n        &gt;&gt;&gt; es_nie('X0095892X')\n        # Output: ValidationError(func=es_nie, args=...)\n\n    Args:\n        value:\n            DOI string which is to be validated.\n\n    Returns:\n        (Literal[True]):\n            If `value` is a valid DOI string.\n        (ValidationError):\n            If `value` is an invalid DOI string.\n\n    &gt; *New in version 0.13.0*.\n    \"\"\"\n    number_by_letter = {\"X\": \"0\", \"Y\": \"1\", \"Z\": \"2\"}\n    # NIE must must start with X Y or Z\n    if value and value[0] in number_by_letter:\n        return _nif_nie_validation(value, number_by_letter, {\"X0000000T\"})\n    return False\n</code></pre>"},{"location":"references/i18n/#validators.i18n.es_nif","title":"<code>validators.i18n.es_nif(value)</code>","text":"<p>Validate a Spanish NIF.</p> <p>Each entity, be it person or company in Spain has a distinct NIF. Since we've designated CIF to be a company NIF, this NIF is only for person. For more information see wikipedia.org/nif. This validator is based on generadordni.es.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; es_nif('26643189N')\n# Output: True\n&gt;&gt;&gt; es_nif('26643189X')\n# Output: ValidationError(func=es_nif, args=...)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>DOI string which is to be validated.</p> required <p>Returns:</p> Type Description <code>Literal[True]</code> <p>If <code>value</code> is a valid DOI string.</p> <code>ValidationError</code> <p>If <code>value</code> is an invalid DOI string.</p> <p>New in version 0.13.0.</p> Source code in <code>src/validators/i18n/es.py</code> <pre><code>@validator\ndef es_nif(value: str, /):\n    \"\"\"Validate a Spanish NIF.\n\n    Each entity, be it person or company in Spain has a distinct NIF. Since\n    we've designated CIF to be a company NIF, this NIF is only for person.\n    For more information see [wikipedia.org/nif][1]. This validator\n    is based on [generadordni.es][2].\n\n    [1]: https://es.wikipedia.org/wiki/N%C3%BAmero_de_identificaci%C3%B3n_fiscal\n    [2]: https://generadordni.es/\n\n    Examples:\n        &gt;&gt;&gt; es_nif('26643189N')\n        # Output: True\n        &gt;&gt;&gt; es_nif('26643189X')\n        # Output: ValidationError(func=es_nif, args=...)\n\n    Args:\n        value:\n            DOI string which is to be validated.\n\n    Returns:\n        (Literal[True]):\n            If `value` is a valid DOI string.\n        (ValidationError):\n            If `value` is an invalid DOI string.\n\n    &gt; *New in version 0.13.0*.\n    \"\"\"\n    number_by_letter = {\"L\": \"0\", \"M\": \"0\", \"K\": \"0\"}\n    special_cases = {\"X0000000T\", \"00000000T\", \"00000001R\"}\n    return _nif_nie_validation(value, number_by_letter, special_cases)\n</code></pre>"},{"location":"references/i18n/#validators.i18n.fi_business_id","title":"<code>validators.i18n.fi_business_id(value)</code>","text":"<p>Validate a Finnish Business ID.</p> <p>Each company in Finland has a distinct business id. For more information see Finnish Trade Register</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; fi_business_id('0112038-9')  # Fast Monkeys Ltd\n# Output: True\n&gt;&gt;&gt; fi_business_id('1234567-8')  # Bogus ID\n# Output: ValidationError(func=fi_business_id, ...)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>Business ID string to be validated.</p> required <p>Returns:</p> Type Description <code>Literal[True]</code> <p>If <code>value</code> is a valid finnish business id.</p> <code>ValidationError</code> <p>If <code>value</code> is an invalid finnish business id.</p> Note <ul> <li>In version 0.5.0:<ul> <li>Function renamed from <code>finnish_business_id</code> to <code>fi_business_id</code></li> </ul> </li> </ul> <p>New in version 0.4.0.</p> Source code in <code>src/validators/i18n/fi.py</code> <pre><code>@validator\ndef fi_business_id(value: str, /):\n    \"\"\"Validate a Finnish Business ID.\n\n    Each company in Finland has a distinct business id. For more\n    information see [Finnish Trade Register][1]\n\n    [1]: http://en.wikipedia.org/wiki/Finnish_Trade_Register\n\n    Examples:\n        &gt;&gt;&gt; fi_business_id('0112038-9')  # Fast Monkeys Ltd\n        # Output: True\n        &gt;&gt;&gt; fi_business_id('1234567-8')  # Bogus ID\n        # Output: ValidationError(func=fi_business_id, ...)\n\n    Args:\n        value:\n            Business ID string to be validated.\n\n    Returns:\n        (Literal[True]):\n            If `value` is a valid finnish business id.\n        (ValidationError):\n            If `value` is an invalid finnish business id.\n\n    Note:\n        - *In version 0.5.0*:\n            - Function renamed from `finnish_business_id` to `fi_business_id`\n\n    &gt; *New in version 0.4.0*.\n    \"\"\"\n    if not value:\n        return False\n    if not re.match(_business_id_pattern(), value):\n        return False\n    factors = [7, 9, 10, 5, 8, 4, 2]\n    numbers = map(int, value[:7])\n    checksum = int(value[8])\n    modulo = sum(f * n for f, n in zip(factors, numbers)) % 11\n    return (11 - modulo == checksum) or (modulo == checksum == 0)\n</code></pre>"},{"location":"references/i18n/#validators.i18n.fi_ssn","title":"<code>validators.i18n.fi_ssn(value, /, *, allow_temporal_ssn=True)</code>","text":"<p>Validate a Finnish Social Security Number.</p> <p>This validator is based on django-localflavor-fi.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; fi_ssn('010101-0101')\n# Output: True\n&gt;&gt;&gt; fi_ssn('101010-0102')\n# Output: ValidationError(func=fi_ssn, args=...)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>Social Security Number to be validated.</p> required <code>allow_temporal_ssn</code> <code>bool</code> <p>Whether to accept temporal SSN numbers. Temporal SSN numbers are the ones where the serial is in the range [900-999]. By default temporal SSN numbers are valid.</p> <code>True</code> <p>Returns:</p> Type Description <code>Literal[True]</code> <p>If <code>value</code> is a valid finnish SSN.</p> <code>ValidationError</code> <p>If <code>value</code> is an invalid finnish SSN.</p> <p>New in version 0.5.0.</p> Source code in <code>src/validators/i18n/fi.py</code> <pre><code>@validator\ndef fi_ssn(value: str, /, *, allow_temporal_ssn: bool = True):\n    \"\"\"Validate a Finnish Social Security Number.\n\n    This validator is based on [django-localflavor-fi][1].\n\n    [1]: https://github.com/django/django-localflavor-fi/\n\n    Examples:\n        &gt;&gt;&gt; fi_ssn('010101-0101')\n        # Output: True\n        &gt;&gt;&gt; fi_ssn('101010-0102')\n        # Output: ValidationError(func=fi_ssn, args=...)\n\n    Args:\n        value:\n            Social Security Number to be validated.\n        allow_temporal_ssn:\n            Whether to accept temporal SSN numbers. Temporal SSN numbers are the\n            ones where the serial is in the range [900-999]. By default temporal\n            SSN numbers are valid.\n\n    Returns:\n        (Literal[True]):\n            If `value` is a valid finnish SSN.\n        (ValidationError):\n            If `value` is an invalid finnish SSN.\n\n    &gt; *New in version 0.5.0*.\n    \"\"\"\n    if not value:\n        return False\n    ssn_check_marks = \"0123456789ABCDEFHJKLMNPRSTUVWXY\"\n    if not (result := re.match(_ssn_pattern(ssn_check_marks), value)):\n        return False\n    gd = result.groupdict()\n    checksum = int(gd[\"date\"] + gd[\"serial\"])\n    return (\n        int(gd[\"serial\"]) &gt;= 2\n        and (allow_temporal_ssn or int(gd[\"serial\"]) &lt;= 899)\n        and ssn_check_marks[checksum % len(ssn_check_marks)] == gd[\"checksum\"]\n    )\n</code></pre>"},{"location":"references/i18n/#validators.i18n.fr_department","title":"<code>validators.i18n.fr_department(value)</code>","text":"<p>Validate a french department number.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; fr_department(20)  # can be an integer\n# Output: True\n&gt;&gt;&gt; fr_department(\"20\")\n# Output: True\n&gt;&gt;&gt; fr_department(\"971\")  # Guadeloupe\n# Output: True\n&gt;&gt;&gt; fr_department(\"00\")\n# Output: ValidationError(func=fr_department, args=...)\n&gt;&gt;&gt; fr_department('2A')  # Corsica\n# Output: True\n&gt;&gt;&gt; fr_department('2B')\n# Output: True\n&gt;&gt;&gt; fr_department('2C')\n# Output: ValidationError(func=fr_department, args=...)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Union[str, int]</code> <p>French department number to validate.</p> required <p>Returns:</p> Type Description <code>Literal[True]</code> <p>If <code>value</code> is a valid french department number.</p> <code>ValidationError</code> <p>If <code>value</code> is an invalid french department number.</p> <p>New in version 0.23.0.</p> Source code in <code>src/validators/i18n/fr.py</code> <pre><code>@validator\ndef fr_department(value: typing.Union[str, int]):\n    \"\"\"Validate a french department number.\n\n    Examples:\n        &gt;&gt;&gt; fr_department(20)  # can be an integer\n        # Output: True\n        &gt;&gt;&gt; fr_department(\"20\")\n        # Output: True\n        &gt;&gt;&gt; fr_department(\"971\")  # Guadeloupe\n        # Output: True\n        &gt;&gt;&gt; fr_department(\"00\")\n        # Output: ValidationError(func=fr_department, args=...)\n        &gt;&gt;&gt; fr_department('2A')  # Corsica\n        # Output: True\n        &gt;&gt;&gt; fr_department('2B')\n        # Output: True\n        &gt;&gt;&gt; fr_department('2C')\n        # Output: ValidationError(func=fr_department, args=...)\n\n    Args:\n        value:\n            French department number to validate.\n\n    Returns:\n        (Literal[True]):\n            If `value` is a valid french department number.\n        (ValidationError):\n            If `value` is an invalid french department number.\n\n    &gt; *New in version 0.23.0*.\n    \"\"\"\n    if not value:\n        return False\n    if isinstance(value, str):\n        if value in (\"2A\", \"2B\"):  # Corsica\n            return True\n        try:\n            value = int(value)\n        except ValueError:\n            return False\n    return 1 &lt;= value &lt;= 19 or 21 &lt;= value &lt;= 95 or 971 &lt;= value &lt;= 976  # Overseas departments\n</code></pre>"},{"location":"references/i18n/#validators.i18n.fr_ssn","title":"<code>validators.i18n.fr_ssn(value)</code>","text":"<p>Validate a french Social Security Number.</p> <p>Each french citizen has a distinct Social Security Number. For more information see French Social Security Number (sadly unavailable in english).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; fr_ssn('1 84 12 76 451 089 46')\n# Output: True\n&gt;&gt;&gt; fr_ssn('1 84 12 76 451 089')  # control key is optional\n# Output: True\n&gt;&gt;&gt; fr_ssn('3 84 12 76 451 089 46')  # wrong gender number\n# Output: ValidationError(func=fr_ssn, args=...)\n&gt;&gt;&gt; fr_ssn('1 84 12 76 451 089 47')  # wrong control key\n# Output: ValidationError(func=fr_ssn, args=...)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>French Social Security Number string to validate.</p> required <p>Returns:</p> Type Description <code>Literal[True]</code> <p>If <code>value</code> is a valid french Social Security Number.</p> <code>ValidationError</code> <p>If <code>value</code> is an invalid french Social Security Number.</p> <p>New in version 0.23.0.</p> Source code in <code>src/validators/i18n/fr.py</code> <pre><code>@validator\ndef fr_ssn(value: str):\n    \"\"\"Validate a french Social Security Number.\n\n    Each french citizen has a distinct Social Security Number.\n    For more information see [French Social Security Number][1] (sadly unavailable in english).\n\n    [1]: https://fr.wikipedia.org/wiki/Num%C3%A9ro_de_s%C3%A9curit%C3%A9_sociale_en_France\n\n    Examples:\n        &gt;&gt;&gt; fr_ssn('1 84 12 76 451 089 46')\n        # Output: True\n        &gt;&gt;&gt; fr_ssn('1 84 12 76 451 089')  # control key is optional\n        # Output: True\n        &gt;&gt;&gt; fr_ssn('3 84 12 76 451 089 46')  # wrong gender number\n        # Output: ValidationError(func=fr_ssn, args=...)\n        &gt;&gt;&gt; fr_ssn('1 84 12 76 451 089 47')  # wrong control key\n        # Output: ValidationError(func=fr_ssn, args=...)\n\n    Args:\n        value:\n            French Social Security Number string to validate.\n\n    Returns:\n        (Literal[True]):\n            If `value` is a valid french Social Security Number.\n        (ValidationError):\n            If `value` is an invalid french Social Security Number.\n\n    &gt; *New in version 0.23.0*.\n    \"\"\"\n    if not value:\n        return False\n    matched = re.match(_ssn_pattern(), value)\n    if not matched:\n        return False\n    groups = list(matched.groups())\n    control_key = groups[-1]\n    department = groups[3]\n    if department != \"99\" and not fr_department(department):\n        # 99 stands for foreign born people\n        return False\n    if control_key is None:\n        # no control key provided, no additional check needed\n        return True\n    if len(department) == len(groups[4]):\n        # if the department number is 3 digits long (overseas departments),\n        # the town number must be 2 digits long\n        # and vice versa\n        return False\n    if department in (\"2A\", \"2B\"):\n        # Corsica's department numbers are not in the same range as the others\n        # thus 2A and 2B are replaced by 19 and 18 respectively to compute the control key\n        groups[3] = \"19\" if department == \"2A\" else \"18\"\n    # the control key is valid if it is equal to 97 - (the first 13 digits modulo 97)\n    digits = int(\"\".join(groups[:-1]))\n    return int(control_key) == (97 - (digits % 97))\n</code></pre>"},{"location":"references/iban/","title":"iban","text":""},{"location":"references/iban/#validators.iban.iban","title":"<code>validators.iban.iban(value)</code>","text":"<p>Return whether or not given value is a valid IBAN code.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; iban('DE29100500001061045672')\n# Output: True\n&gt;&gt;&gt; iban('123456')\n# Output: ValidationError(func=iban, ...)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>IBAN string to validate.</p> required <p>Returns:</p> Type Description <code>Literal[True]</code> <p>If <code>value</code> is a valid IBAN code.</p> <code>ValidationError</code> <p>If <code>value</code> is an invalid IBAN code.</p> <p>New in version 0.8.0</p> Source code in <code>src/validators/iban.py</code> <pre><code>@validator\ndef iban(value: str, /):\n    \"\"\"Return whether or not given value is a valid IBAN code.\n\n    Examples:\n        &gt;&gt;&gt; iban('DE29100500001061045672')\n        # Output: True\n        &gt;&gt;&gt; iban('123456')\n        # Output: ValidationError(func=iban, ...)\n\n    Args:\n        value:\n            IBAN string to validate.\n\n    Returns:\n        (Literal[True]):\n            If `value` is a valid IBAN code.\n        (ValidationError):\n            If `value` is an invalid IBAN code.\n\n    &gt; *New in version 0.8.0*\n    \"\"\"\n    return (\n        (re.match(r\"^[A-Z]{2}[0-9]{2}[A-Z0-9]{11,30}$\", value) and _mod_check(value))\n        if value\n        else False\n    )\n</code></pre>"},{"location":"references/ip_address/","title":"ip_address","text":""},{"location":"references/ip_address/#validators.ip_address.ipv4","title":"<code>validators.ip_address.ipv4(value, /, *, cidr=True, strict=False, host_bit=True)</code>","text":"<p>Returns whether a given value is a valid IPv4 address.</p> <p>From Python version 3.9.5 leading zeros are no longer tolerated and are treated as an error. The initial version of ipv4 validator was inspired from WTForms IPAddress validator.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; ipv4('123.0.0.7')\n# Output: True\n&gt;&gt;&gt; ipv4('1.1.1.1/8')\n# Output: True\n&gt;&gt;&gt; ipv4('900.80.70.11')\n# Output: ValidationError(func=ipv4, args={'value': '900.80.70.11'})\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>IP address string to validate.</p> required <code>cidr</code> <code>bool</code> <p>IP address string may contain CIDR notation</p> <code>True</code> <code>strict</code> <code>bool</code> <p>IP address string is strictly in CIDR notation</p> <code>False</code> <code>host_bit</code> <code>bool</code> <p>If <code>False</code> and host bits (along with network bits) are set in the supplied address, this function raises a validation error. ref IPv4Network.</p> <code>True</code> <p>Returns:</p> Type Description <code>Literal[True]</code> <p>If <code>value</code> is a valid IPv4 address.</p> <code>ValidationError</code> <p>If <code>value</code> is an invalid IPv4 address.</p> Note <ul> <li>In version 0.14.0:<ul> <li>Add supports for CIDR notation</li> </ul> </li> </ul> <p>New in version 0.2.0</p> Source code in <code>src/validators/ip_address.py</code> <pre><code>@validator\ndef ipv4(value: str, /, *, cidr: bool = True, strict: bool = False, host_bit: bool = True):\n    \"\"\"Returns whether a given value is a valid IPv4 address.\n\n    From Python version 3.9.5 leading zeros are no longer tolerated\n    and are treated as an error. The initial version of ipv4 validator\n    was inspired from [WTForms IPAddress validator][1].\n\n    [1]: https://github.com/wtforms/wtforms/blob/master/src/wtforms/validators.py\n\n    Examples:\n        &gt;&gt;&gt; ipv4('123.0.0.7')\n        # Output: True\n        &gt;&gt;&gt; ipv4('1.1.1.1/8')\n        # Output: True\n        &gt;&gt;&gt; ipv4('900.80.70.11')\n        # Output: ValidationError(func=ipv4, args={'value': '900.80.70.11'})\n\n    Args:\n        value:\n            IP address string to validate.\n        cidr:\n            IP address string may contain CIDR notation\n        strict:\n            IP address string is strictly in CIDR notation\n        host_bit:\n            If `False` and host bits (along with network bits) _are_ set in the supplied\n            address, this function raises a validation error. ref [IPv4Network][2].\n            [2]: https://docs.python.org/3/library/ipaddress.html#ipaddress.IPv4Network\n\n    Returns:\n        (Literal[True]):\n            If `value` is a valid IPv4 address.\n        (ValidationError):\n            If `value` is an invalid IPv4 address.\n\n    Note:\n        - *In version 0.14.0*:\n            - Add supports for CIDR notation\n\n    &gt; *New in version 0.2.0*\n    \"\"\"\n    if not value:\n        return False\n    try:\n        if cidr:\n            if strict and value.count(\"/\") != 1:\n                raise ValueError(\"IPv4 address was expected in CIDR notation\")\n            return IPv4Network(value, strict=not host_bit)\n        return IPv4Address(value)\n    except (ValueError, AddressValueError, NetmaskValueError):\n        return False\n</code></pre>"},{"location":"references/ip_address/#validators.ip_address.ipv6","title":"<code>validators.ip_address.ipv6(value, /, *, cidr=True, strict=False, host_bit=True)</code>","text":"<p>Returns if a given value is a valid IPv6 address.</p> <p>Including IPv4-mapped IPv6 addresses. The initial version of ipv6 validator was inspired from WTForms IPAddress validator.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; ipv6('::ffff:192.0.2.128')\n# Output: True\n&gt;&gt;&gt; ipv6('::1/128')\n# Output: True\n&gt;&gt;&gt; ipv6('abc.0.0.1')\n# Output: ValidationError(func=ipv6, args={'value': 'abc.0.0.1'})\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>IP address string to validate.</p> required <code>cidr</code> <code>bool</code> <p>IP address string may contain CIDR annotation</p> <code>True</code> <code>strict</code> <code>bool</code> <p>IP address string is strictly in CIDR notation</p> <code>False</code> <code>host_bit</code> <code>bool</code> <p>If <code>False</code> and host bits (along with network bits) are set in the supplied address, this function raises a validation error. ref IPv6Network.</p> <code>True</code> <p>Returns:</p> Type Description <code>Literal[True]</code> <p>If <code>value</code> is a valid IPv6 address.</p> <code>ValidationError</code> <p>If <code>value</code> is an invalid IPv6 address.</p> Note <ul> <li>In version 0.14.0:<ul> <li>Add supports for CIDR notation</li> </ul> </li> </ul> <p>New in version 0.2.0</p> Source code in <code>src/validators/ip_address.py</code> <pre><code>@validator\ndef ipv6(value: str, /, *, cidr: bool = True, strict: bool = False, host_bit: bool = True):\n    \"\"\"Returns if a given value is a valid IPv6 address.\n\n    Including IPv4-mapped IPv6 addresses. The initial version of ipv6 validator\n    was inspired from [WTForms IPAddress validator][1].\n\n    [1]: https://github.com/wtforms/wtforms/blob/master/src/wtforms/validators.py\n\n    Examples:\n        &gt;&gt;&gt; ipv6('::ffff:192.0.2.128')\n        # Output: True\n        &gt;&gt;&gt; ipv6('::1/128')\n        # Output: True\n        &gt;&gt;&gt; ipv6('abc.0.0.1')\n        # Output: ValidationError(func=ipv6, args={'value': 'abc.0.0.1'})\n\n    Args:\n        value:\n            IP address string to validate.\n        cidr:\n            IP address string may contain CIDR annotation\n        strict:\n            IP address string is strictly in CIDR notation\n        host_bit:\n            If `False` and host bits (along with network bits) _are_ set in the supplied\n            address, this function raises a validation error. ref [IPv6Network][2].\n            [2]: https://docs.python.org/3/library/ipaddress.html#ipaddress.IPv6Network\n\n    Returns:\n        (Literal[True]):\n            If `value` is a valid IPv6 address.\n        (ValidationError):\n            If `value` is an invalid IPv6 address.\n\n    Note:\n        - *In version 0.14.0*:\n            - Add supports for CIDR notation\n\n    &gt; *New in version 0.2.0*\n    \"\"\"\n    if not value:\n        return False\n    try:\n        if cidr:\n            if strict and value.count(\"/\") != 1:\n                raise ValueError(\"IPv6 address was expected in CIDR notation\")\n            return IPv6Network(value, strict=not host_bit)\n        return IPv6Address(value)\n    except (ValueError, AddressValueError, NetmaskValueError):\n        return False\n</code></pre>"},{"location":"references/length/","title":"length","text":""},{"location":"references/length/#validators.length.length","title":"<code>validators.length.length(value, /, *, min_val=None, max_val=None)</code>","text":"<p>Return whether or not the length of given string is within a specified range.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; length('something', min_val=2)\n# Output: True\n&gt;&gt;&gt; length('something', min_val=9, max_val=9)\n# Output: True\n&gt;&gt;&gt; length('something', max_val=5)\n# Output: ValidationError(func=length, ...)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>The string to validate.</p> required <code>min_val</code> <code>Union[int, None]</code> <p>The minimum required length of the string. If not provided, minimum length will not be checked.</p> <code>None</code> <code>max_val</code> <code>Union[int, None]</code> <p>The maximum length of the string. If not provided, maximum length will not be checked.</p> <code>None</code> <p>Returns:</p> Type Description <code>Literal[True]</code> <p>If <code>len(value)</code> is in between the given conditions.</p> <code>ValidationError</code> <p>If <code>len(value)</code> is not in between the given conditions.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If either <code>min_val</code> or <code>max_val</code> is negative.</p> Source code in <code>src/validators/length.py</code> <pre><code>@validator\ndef length(value: str, /, *, min_val: Union[int, None] = None, max_val: Union[int, None] = None):\n    \"\"\"Return whether or not the length of given string is within a specified range.\n\n    Examples:\n        &gt;&gt;&gt; length('something', min_val=2)\n        # Output: True\n        &gt;&gt;&gt; length('something', min_val=9, max_val=9)\n        # Output: True\n        &gt;&gt;&gt; length('something', max_val=5)\n        # Output: ValidationError(func=length, ...)\n\n    Args:\n        value:\n            The string to validate.\n        min_val:\n            The minimum required length of the string. If not provided,\n            minimum length will not be checked.\n        max_val:\n            The maximum length of the string. If not provided,\n            maximum length will not be checked.\n\n    Returns:\n        (Literal[True]):\n            If `len(value)` is in between the given conditions.\n        (ValidationError):\n            If `len(value)` is not in between the given conditions.\n\n    Raises:\n        (ValueError): If either `min_val` or `max_val` is negative.\n    \"\"\"\n    if min_val is not None and min_val &lt; 0:\n        raise ValueError(\"Length cannot be negative. `min_val` is less than zero.\")\n    if max_val is not None and max_val &lt; 0:\n        raise ValueError(\"Length cannot be negative. `max_val` is less than zero.\")\n\n    return bool(between(len(value), min_val=min_val, max_val=max_val))\n</code></pre>"},{"location":"references/mac_address/","title":"mac_address","text":""},{"location":"references/mac_address/#validators.mac_address.mac_address","title":"<code>validators.mac_address.mac_address(value)</code>","text":"<p>Return whether or not given value is a valid MAC address.</p> <p>This validator is based on WTForms MacAddress validator.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; mac_address('01:23:45:67:ab:CD')\n# Output: True\n&gt;&gt;&gt; mac_address('00:00:00:00:00')\n# Output: ValidationError(func=mac_address, args={'value': '00:00:00:00:00'})\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>MAC address string to validate.</p> required <p>Returns:</p> Type Description <code>Literal[True]</code> <p>If <code>value</code> is a valid MAC address.</p> <code>ValidationError</code> <p>If <code>value</code> is an invalid MAC address.</p> <p>New in version 0.2.0.</p> Source code in <code>src/validators/mac_address.py</code> <pre><code>@validator\ndef mac_address(value: str, /):\n    \"\"\"Return whether or not given value is a valid MAC address.\n\n    This validator is based on [WTForms MacAddress validator][1].\n\n    [1]: https://github.com/wtforms/wtforms/blob/master/src/wtforms/validators.py#L482\n\n    Examples:\n        &gt;&gt;&gt; mac_address('01:23:45:67:ab:CD')\n        # Output: True\n        &gt;&gt;&gt; mac_address('00:00:00:00:00')\n        # Output: ValidationError(func=mac_address, args={'value': '00:00:00:00:00'})\n\n    Args:\n        value:\n            MAC address string to validate.\n\n    Returns:\n        (Literal[True]):\n            If `value` is a valid MAC address.\n        (ValidationError):\n            If `value` is an invalid MAC address.\n\n    &gt; *New in version 0.2.0*.\n    \"\"\"\n    return re.match(r\"^([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})$\", value) if value else False\n</code></pre>"},{"location":"references/slug/","title":"slug","text":""},{"location":"references/slug/#validators.slug.slug","title":"<code>validators.slug.slug(value)</code>","text":"<p>Validate whether or not given value is valid slug.</p> <p>Valid slug can contain only lowercase alphanumeric characters and hyphens. It starts and ends with these lowercase alphanumeric characters.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; slug('my-slug-2134')\n# Output: True\n&gt;&gt;&gt; slug('my.slug')\n# Output: ValidationError(func=slug, args={'value': 'my.slug'})\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>Slug string to validate.</p> required <p>Returns:</p> Type Description <code>Literal[True]</code> <p>If <code>value</code> is a valid slug.</p> <code>ValidationError</code> <p>If <code>value</code> is an invalid slug.</p> <p>New in version 0.6.0.</p> Source code in <code>src/validators/slug.py</code> <pre><code>@validator\ndef slug(value: str, /):\n    \"\"\"Validate whether or not given value is valid slug.\n\n    Valid slug can contain only lowercase alphanumeric characters and hyphens.\n    It starts and ends with these lowercase alphanumeric characters.\n\n    Examples:\n        &gt;&gt;&gt; slug('my-slug-2134')\n        # Output: True\n        &gt;&gt;&gt; slug('my.slug')\n        # Output: ValidationError(func=slug, args={'value': 'my.slug'})\n\n    Args:\n        value:\n            Slug string to validate.\n\n    Returns:\n        (Literal[True]):\n            If `value` is a valid slug.\n        (ValidationError):\n            If `value` is an invalid slug.\n\n    &gt; *New in version 0.6.0*.\n    \"\"\"\n    return re.match(r\"^[a-z0-9]+(?:-[a-z0-9]+)*$\", value) if value else False\n</code></pre>"},{"location":"references/url/","title":"url","text":""},{"location":"references/url/#validators.url.url","title":"<code>validators.url.url(value, /, *, skip_ipv6_addr=False, skip_ipv4_addr=False, may_have_port=True, simple_host=False, strict_query=True, rfc_1034=False, rfc_2782=False)</code>","text":"<p>Return whether or not given value is a valid URL.</p> <p>This validator was inspired from URL validator of dperini. The following diagram is from urlly.</p> <pre><code>    foo://admin:hunter1@example.com:8042/over/there?name=ferret#nose\n    \\_/   \\___/ \\_____/ \\_________/ \\__/\\_________/ \\_________/ \\__/\n     |      |       |       |        |       |          |         |\n  scheme username password hostname port    path      query    fragment\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; url('http://duck.com')\n# Output: True\n&gt;&gt;&gt; url('ftp://foobar.dk')\n# Output: True\n&gt;&gt;&gt; url('http://10.0.0.1')\n# Output: True\n&gt;&gt;&gt; url('http://example.com/\"&gt;user@example.com')\n# Output: ValidationError(func=url, ...)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>URL string to validate.</p> required <code>skip_ipv6_addr</code> <code>bool</code> <p>When URL string cannot contain an IPv6 address.</p> <code>False</code> <code>skip_ipv4_addr</code> <code>bool</code> <p>When URL string cannot contain an IPv4 address.</p> <code>False</code> <code>may_have_port</code> <code>bool</code> <p>URL string may contain port number.</p> <code>True</code> <code>simple_host</code> <code>bool</code> <p>URL string maybe only hyphens and alpha-numerals.</p> <code>False</code> <code>strict_query</code> <code>bool</code> <p>Fail validation on query string parsing error.</p> <code>True</code> <code>rfc_1034</code> <code>bool</code> <p>Allow trailing dot in domain/host name. Ref: RFC 1034.</p> <code>False</code> <code>rfc_2782</code> <code>bool</code> <p>Domain/Host name is of type service record. Ref: RFC 2782.</p> <code>False</code> <p>Returns:</p> Type Description <code>Literal[True]</code> <p>If <code>value</code> is a valid slug.</p> <code>ValidationError</code> <p>If <code>value</code> is an invalid slug.</p> Note <ul> <li>In version 0.11.3:<ul> <li>Added support for URLs containing localhost.</li> </ul> </li> <li>In version 0.11.0:<ul> <li>Made the regular expression case insensitive.</li> </ul> </li> <li>In version 0.10.3:<ul> <li>Added a <code>public</code> parameter.</li> </ul> </li> <li>In version 0.10.2:<ul> <li>Added support for various exotic URLs.</li> <li>Fixed various false positives.</li> </ul> </li> </ul> <p>New in version 0.2.0.</p> Source code in <code>src/validators/url.py</code> <pre><code>@validator\ndef url(\n    value: str,\n    /,\n    *,\n    skip_ipv6_addr: bool = False,\n    skip_ipv4_addr: bool = False,\n    may_have_port: bool = True,\n    simple_host: bool = False,\n    strict_query: bool = True,\n    rfc_1034: bool = False,\n    rfc_2782: bool = False,\n):\n    r\"\"\"Return whether or not given value is a valid URL.\n\n    This validator was inspired from [URL validator of dperini][1].\n    The following diagram is from [urlly][2].\n\n            foo://admin:hunter1@example.com:8042/over/there?name=ferret#nose\n            \\_/   \\___/ \\_____/ \\_________/ \\__/\\_________/ \\_________/ \\__/\n             |      |       |       |        |       |          |         |\n          scheme username password hostname port    path      query    fragment\n\n    [1]: https://gist.github.com/dperini/729294\n    [2]: https://github.com/treeform/urlly\n\n    Examples:\n        &gt;&gt;&gt; url('http://duck.com')\n        # Output: True\n        &gt;&gt;&gt; url('ftp://foobar.dk')\n        # Output: True\n        &gt;&gt;&gt; url('http://10.0.0.1')\n        # Output: True\n        &gt;&gt;&gt; url('http://example.com/\"&gt;user@example.com')\n        # Output: ValidationError(func=url, ...)\n\n    Args:\n        value:\n            URL string to validate.\n        skip_ipv6_addr:\n            When URL string cannot contain an IPv6 address.\n        skip_ipv4_addr:\n            When URL string cannot contain an IPv4 address.\n        may_have_port:\n            URL string may contain port number.\n        simple_host:\n            URL string maybe only hyphens and alpha-numerals.\n        strict_query:\n            Fail validation on query string parsing error.\n        rfc_1034:\n            Allow trailing dot in domain/host name.\n            Ref: [RFC 1034](https://www.rfc-editor.org/rfc/rfc1034).\n        rfc_2782:\n            Domain/Host name is of type service record.\n            Ref: [RFC 2782](https://www.rfc-editor.org/rfc/rfc2782).\n\n    Returns:\n        (Literal[True]):\n            If `value` is a valid slug.\n        (ValidationError):\n            If `value` is an invalid slug.\n\n    Note:\n        - *In version 0.11.3*:\n            - Added support for URLs containing localhost.\n        - *In version 0.11.0*:\n            - Made the regular expression case insensitive.\n        - *In version 0.10.3*:\n            - Added a `public` parameter.\n        - *In version 0.10.2*:\n            - Added support for various exotic URLs.\n            - Fixed various false positives.\n\n    &gt; *New in version 0.2.0*.\n    \"\"\"\n    if not value or re.search(r\"\\s\", value):\n        # url must not contain any white\n        # spaces, they must be encoded\n        return False\n\n    try:\n        scheme, netloc, path, query, fragment = urlsplit(value)\n    except ValueError:\n        return False\n\n    return (\n        _validate_scheme(scheme)\n        and _validate_netloc(\n            netloc,\n            skip_ipv6_addr,\n            skip_ipv4_addr,\n            may_have_port,\n            simple_host,\n            rfc_1034,\n            rfc_2782,\n        )\n        and _validate_optionals(path, query, fragment, strict_query)\n    )\n</code></pre>"},{"location":"references/utils/","title":"utils","text":""},{"location":"references/utils/#validators.utils.ValidationError","title":"<code>validators.utils.ValidationError</code>","text":"<p>             Bases: <code>Exception</code></p> <p>Exception class when validation failure occurs.</p> Source code in <code>src/validators/utils.py</code> <pre><code>class ValidationError(Exception):\n    \"\"\"Exception class when validation failure occurs.\"\"\"\n\n    def __init__(self, function: Callable[..., Any], arg_dict: Dict[str, Any], message: str = \"\"):\n        \"\"\"Initialize Validation Failure.\"\"\"\n        if message:\n            self.reason = message\n        self.func = function\n        self.__dict__.update(arg_dict)\n\n    def __repr__(self):\n        \"\"\"Repr Validation Failure.\"\"\"\n        return (\n            f\"ValidationError(func={self.func.__name__}, \"\n            + f\"args={({k: v for (k, v) in self.__dict__.items() if k != 'func'})})\"\n        )\n\n    def __str__(self):\n        \"\"\"Str Validation Failure.\"\"\"\n        return repr(self)\n\n    def __bool__(self):\n        \"\"\"Bool Validation Failure.\"\"\"\n        return False\n</code></pre>"},{"location":"references/utils/#validators.utils.ValidationError.__bool__","title":"<code>__bool__()</code>","text":"<p>Bool Validation Failure.</p> Source code in <code>src/validators/utils.py</code> <pre><code>def __bool__(self):\n    \"\"\"Bool Validation Failure.\"\"\"\n    return False\n</code></pre>"},{"location":"references/utils/#validators.utils.ValidationError.__init__","title":"<code>__init__(function, arg_dict, message='')</code>","text":"<p>Initialize Validation Failure.</p> Source code in <code>src/validators/utils.py</code> <pre><code>def __init__(self, function: Callable[..., Any], arg_dict: Dict[str, Any], message: str = \"\"):\n    \"\"\"Initialize Validation Failure.\"\"\"\n    if message:\n        self.reason = message\n    self.func = function\n    self.__dict__.update(arg_dict)\n</code></pre>"},{"location":"references/utils/#validators.utils.ValidationError.__repr__","title":"<code>__repr__()</code>","text":"<p>Repr Validation Failure.</p> Source code in <code>src/validators/utils.py</code> <pre><code>def __repr__(self):\n    \"\"\"Repr Validation Failure.\"\"\"\n    return (\n        f\"ValidationError(func={self.func.__name__}, \"\n        + f\"args={({k: v for (k, v) in self.__dict__.items() if k != 'func'})})\"\n    )\n</code></pre>"},{"location":"references/utils/#validators.utils.ValidationError.__str__","title":"<code>__str__()</code>","text":"<p>Str Validation Failure.</p> Source code in <code>src/validators/utils.py</code> <pre><code>def __str__(self):\n    \"\"\"Str Validation Failure.\"\"\"\n    return repr(self)\n</code></pre>"},{"location":"references/utils/#validators.utils.validator","title":"<code>validators.utils.validator(func)</code>","text":"<p>A decorator that makes given function validator.</p> <p>Whenever the given <code>func</code> returns <code>False</code> this decorator returns <code>ValidationError</code> object.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; @validator\n... def even(value):\n...     return not (value % 2)\n&gt;&gt;&gt; even(4)\n# Output: True\n&gt;&gt;&gt; even(5)\n# Output: ValidationError(func=even, args={'value': 5})\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[..., Any]</code> <p>Function which is to be decorated.</p> required <p>Returns:</p> Type Description <code>Callable[..., ValidationError | Literal[True]]</code> <p>A decorator which returns either <code>ValidationError</code> or <code>Literal[True]</code>.</p> <p>New in version 2013.10.21.</p> Source code in <code>src/validators/utils.py</code> <pre><code>def validator(func: Callable[..., Any]):\n    \"\"\"A decorator that makes given function validator.\n\n    Whenever the given `func` returns `False` this\n    decorator returns `ValidationError` object.\n\n    Examples:\n        &gt;&gt;&gt; @validator\n        ... def even(value):\n        ...     return not (value % 2)\n        &gt;&gt;&gt; even(4)\n        # Output: True\n        &gt;&gt;&gt; even(5)\n        # Output: ValidationError(func=even, args={'value': 5})\n\n    Args:\n        func:\n            Function which is to be decorated.\n\n    Returns:\n        (Callable[..., ValidationError | Literal[True]]):\n            A decorator which returns either `ValidationError`\n            or `Literal[True]`.\n\n    &gt; *New in version 2013.10.21*.\n    \"\"\"\n\n    @wraps(func)\n    def wrapper(*args: Any, **kwargs: Any):\n        try:\n            return (\n                True\n                if func(*args, **kwargs)\n                else ValidationError(func, _func_args_as_dict(func, *args, **kwargs))\n            )\n        except Exception as exp:\n            return ValidationError(func, _func_args_as_dict(func, *args, **kwargs), str(exp))\n\n    return wrapper\n</code></pre>"},{"location":"references/uuid/","title":"uuid","text":""},{"location":"references/uuid/#validators.uuid.uuid","title":"<code>validators.uuid.uuid(value)</code>","text":"<p>Return whether or not given value is a valid UUID-v4 string.</p> <p>This validator is based on WTForms UUID validator.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; uuid('2bc1c94f-0deb-43e9-92a1-4775189ec9f8')\n# Output: True\n&gt;&gt;&gt; uuid('2bc1c94f 0deb-43e9-92a1-4775189ec9f8')\n# Output: ValidationError(func=uuid, ...)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Union[str, UUID]</code> <p>UUID string or object to validate.</p> required <p>Returns:</p> Type Description <code>Literal[True]</code> <p>If <code>value</code> is a valid UUID.</p> <code>ValidationError</code> <p>If <code>value</code> is an invalid UUID.</p> <p>New in version 0.2.0.</p> Source code in <code>src/validators/uuid.py</code> <pre><code>@validator\ndef uuid(value: Union[str, UUID], /):\n    \"\"\"Return whether or not given value is a valid UUID-v4 string.\n\n    This validator is based on [WTForms UUID validator][1].\n\n    [1]: https://github.com/wtforms/wtforms/blob/master/src/wtforms/validators.py#L539\n\n    Examples:\n        &gt;&gt;&gt; uuid('2bc1c94f-0deb-43e9-92a1-4775189ec9f8')\n        # Output: True\n        &gt;&gt;&gt; uuid('2bc1c94f 0deb-43e9-92a1-4775189ec9f8')\n        # Output: ValidationError(func=uuid, ...)\n\n    Args:\n        value:\n            UUID string or object to validate.\n\n    Returns:\n        (Literal[True]):\n            If `value` is a valid UUID.\n        (ValidationError):\n            If `value` is an invalid UUID.\n\n    &gt; *New in version 0.2.0*.\n    \"\"\"\n    if not value:\n        return False\n    if isinstance(value, UUID):\n        return True\n    try:\n        return UUID(value) or re.match(\n            r\"^[0-9a-fA-F]{8}-([0-9a-fA-F]{4}-){3}[0-9a-fA-F]{12}$\", value\n        )\n    except ValueError:\n        return False\n</code></pre>"}]}